# Multi-table to Network

### 背景

[Karma](https://github.com/usc-isi-i2/Web-Karma) 工具可以使用本体对数据进行标注，但 Karma 也存在以下两点不足：

- 只能标注单表数据，不能标注多表数据；
- 使用 SQL 导入多表需要建立 JOIN 关系，容易产生大量冗余数据。

因此，我们需要开发一种支持多表标注且冗余数据量小的多表标注算法。

### 介绍

Multi-table to Network (MT2N) 输入 Karma 导出的 RDF 文件，输出 JSON 格式的图。

MT2N 支持以下功能：

- 实体类型和表的对应关系可以是一对一、一对多或多对一。即每张表中可以存在多个实体类型，每个实体类型可以存在于多张表内。
- 更加灵活的实体整合方式。相较于 SQL 严格的主外码关系，MT2N 没有严格的主外键关系。
- 低冗余数据。MT2N 的结果是一张图网络，这种存储方式比表格具有更少的冗余数据，且利于分析。

### 输入

TXT 文件（每行包含一个路径，对应一个 Karma 导出的 RDF 文件）。

### 输出

1. 图网络 JSON 文件

   格式如下：

   ```json
   {"Vertices":[
   	{"id":0,"entity_type":0,"properties":"{'model': 'ChrSy.fgenesh.mRNA.1',..."},
   	{}
   ]},
   {"Edges":[
   	{"source_id":1000,"target_id":3,"relationship":0},
   	{}
   ]}
   ```

2. 实体与关系编号的对应文件
   
   格式如下：
   
   ```
   Gene	0
   Go_classification	1
   
   PartOf	0
   ```

### 算法思想

![image-20210415144731015](https://i.loli.net/2021/04/15/I1jo9cgeUpdDsM7.png)

| **Algorithm 1** Multi-table to Network                       |
| ------------------------------------------------------------ |
| **Input**: graph generated by RDF files *q*<br />**Output**: merged graph *g* |

```
g := DiGraph();
components := ConnectedComponents(q);
for each c ∈ components do
	for each u ∈ V(c) do
		if TypeOf(u) != 'Source' then
			continue;
		end if
		if u ∉ V(g) then
			AddNode(g, u);
		end if
		MergeDataProperties(g, u);
		
		uc := ToUndirected(c);
		pairs := BfsEdges(uc, IdOf(u));
		for each (s, t) ∈ pairs do
			SpecialCheck(t)
			if t ∉ V(g) then
				AddNode(g, t);
			end if
			MergeDataProperties(g, t);
			if HasEdge(s, t) then
				AddEdge(s, t)
			else
				AddEdge(t, s)
			end if
		end for
	end for
end for
```

1. 读取 RDF 文件对应的有向图 *q*，生成空的有向图*g*。
2. 求出图*q*的所有连通子图*components*。

2. 遍历*components*中的元素*c*，找到*c*中类型为 Source 的结点*u*，并检查该结点是否在图*g*中。若不存在，在*g*中加入该结点。将*q*中的原结点数据属性赋给*g*中对应的结点。求出*c*对应的无向图*uc*，使用 BFS 算法得出无向图*uc*中从*u*结点开始的遍历结果，保存为二元组组成的列表*pairs*。遍历*pairs*中的二元组 (*s*, *t*)，对*t*进行特殊判断^[1]^（如需直接加入，跳出该层循环）。检查*t*结点是否在图*g*中，若不存在，在*g*中加入该结点。将*q*中的原结点数据属性赋给*g*中对应的结点。判断*s*和*t*结点连接的方向，在*g*中加入*s*和*t*对应的边。

[1] SpecialCheck()：检查结点*t*是否需要特殊判断，直接加入图*g*。对于结点 Gene，有些子结点只能存在一个，如 Location，而有些结点可以存在多个，包括 Interpro、Pfam、Go_classification 和 Sequence。对于后者，该算法会将结点直接加入图*g*。
